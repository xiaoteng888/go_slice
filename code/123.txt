HTTP缺点                                                           ！！！
通信使用明文，可能被窃听
不验证通信方的身份，可能遭遇伪装
无法证明报文的完整性，有可能遭遇篡改
HTTP协议永远都是客户端发起请求，服务器回送响应。

HTTPS                                                                   ！！！
HTTP+加密+认证+完整性保护 = HTTPS
HTTPS是在HTTP上建立SSL加密层，并对传输数据进行加密，是HTTP协议的安全版。HTTPS主要作用是：
对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全
对网站服务器进行真实身份认证

TCP/IP 指传输控制协议/网际协议
TCP (传输控制协议) - 应用程序之间通信
UDP (用户数据报协议) - 应用程序之间的简单通信
IP (网际协议) - 计算机之间的通信
ICMP (因特网消息控制协议) - 针对错误和状态
DHCP (动态主机配置协议) - 针对动态寻址

TCP 负责将数据分割并装入 IP 包，然后在它们到达的时候重新组合它们。
IP 负责将包发送至接受者。
TCP 为提供可靠性传输，实行“顺序控制”或“重发控制”机制。此外还具备“流控制（流量控制）”、“拥塞控制”、提高网络利用率等众多功能。
UDP 是不具有可靠性的数据报协议。细微的处理它会交给上层的应用去完成。在 UDP 的情况下，虽然可以确保发送消息的大小，
却不能保证消息一定会到达。
TCP 用于在传输层有必要实现可靠传输的情况；而在一方面，UDP 主要用于那些对高速传输和实时性有较高要求的通信或广播通信

PHP动态调整内存限制：ini_set('memory_limit', '1024M');    ！！！


                                                           ！！！
普通http只能是客户端请求服务端 服务端应答  ws可以服务端主动询问客户端。
客服系统 游戏服务 消息通知都用

数据库                                                                 ！！！
表的类型分别是：BDB、HEAP(MEMORY)、ISAM、MERGE(一组MYISAM的组合)、MYISAM、InnoBDB
事务安全型：包括BDB和InnoDB；其余都属于第二类非事务安全型
MyISAM 和InnoDB                                              ！！！
基本的差别为：MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持。 MyISAM类型的表强调的是性能，
其执行速度比InnoDB类型更快，但是不提供事务支持，MyISAM引擎的MySQL可以提供高速存储和检索，
以及全文搜索能力，适合数据仓库等查询频繁的应用，
而InnoDB提供事务支持以及外部键等高级数据库功能。
InnoDB存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全存储引擎。

数据库字段：TEXT与BLOB的主要差别就是BLOB保存二进制数据，TEXT保存字符数据，
blob可以把图片转成二进制存入数据库(tinyblob,blob,MEDIUMBLOB,LONGBLOB)           ！！！

共享锁与排他锁                                                                                              ！！！
共享锁（读锁）：其他事务可以读，但不能写。
排他锁（写锁） ：其他事务不能读取，也不能写。
MyISAM 和 MEMORY 存储引擎采用的是表级锁
BDB 存储引擎采用的是页面锁，但也支持表级锁
InnoDB 存储引擎既支持行级锁，也支持表级锁，但默认情况下是采用行级锁。
默认情况下，表锁和行锁都是自动获得的， 不需要额外的命令。

表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。
这些存储引擎通过总是一次性同时获取所有需要的锁以及总是按相同的顺序获取表锁来避免死锁。
表级锁更适合于以查询为主，并发用户少，只有少量按索引条件更新数据的应用，如Web 应用

行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。
最大程度的支持并发，同时也带来了最大的锁开销。
在 InnoDB 中，除单个 SQL 组成的事务外，
锁是逐步获得的，这就决定了在 InnoDB 中发生死锁是可能的。
行级锁只在存储引擎层实现，而Mysql服务器层没有实现。 行级锁更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，
如一些在线事务处理系统
页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。

MyISAM表级锁模式：当一个线程获得对一个表的写锁后，只有持有锁的线程可以对表进行更新操作。
 其他线程的读、 写操作都会等待，直到锁被释放为止。
默认情况下，写锁比读锁具有更高的优先级：当一个锁释放时，这个锁会优先给写锁队列中等候的获取锁请求，
然后再给读锁队列中等候的获取锁请求。 这也正是 MyISAM 表不太适合于有大量更新操作和查询操作应用的原因，
因为，大量的更新操作会造成查询操作很难获得读锁，从而可能永远阻塞
MyISAM加表锁方法：
MyISAM 在执行查询语句（SELECT）前，会自动给涉及的表加读锁，在执行更新操作（UPDATE、DELETE、INSERT 等）前，
会自动给涉及的表加写锁，这个过程并不需要用户干预，因此，用户一般不需要直接用 LOCK TABLE 命令给 MyISAM 表显式加锁。
在自动加锁的情况下，MyISAM 总是一次获得 SQL 语句所需要的全部锁，这也正是 MyISAM 表不会出现死锁（Deadlock Free）的原因。

InnoDB加锁方法：
意向锁是 InnoDB 自动加的， 不需用户干预。
对于 UPDATE、 DELETE 和 INSERT 语句， InnoDB
会自动给涉及数据集加排他锁（X)；
对于普通 SELECT 语句，InnoDB 不会加任何锁；
事务可以通过以下语句显式给记录集加共享锁或排他锁：
共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE。 其他 session 仍然可以查询记录，
并也可以对该记录加 share mode 的共享锁。但是如果当前事务需要对该记录进行更新操作，则很有可能造成死锁。
排他锁（X)：SELECT * FROM table_name WHERE ... FOR UPDATE。其他 session 可以查询该记录，
但是不能对该记录加共享锁或排他锁，而是等待获得锁
锁只有在执行commit或者rollback的时候才会释放，并且所有的锁都是在同一时刻被释放

select *** for update 的使用场景：为了让自己查到的数据确保是最新数据，并且查到后的数据只允许自己来修改的时候，
需要用到 for update 子句。
select *** lock in share mode 使用场景：为了确保自己查到的数据没有被其他的事务正在修改，也就是说确保查到的数据是最新的数据，
并且不允许其他人来修改数据。但是自己不一定能够修改数据，因为有可能其他的事务也对这些数据 使用了 in share mode 的方式上了 S 锁。
性能影响：
select for update 语句，相当于一个 update 语句。在业务繁忙的情况下，如果事务没有及时的commit或者rollback 
可能会造成其他事务长时间的等待，从而影响数据库的并发使用效率。
select lock in share mode 语句是一个给查找的数据上一个共享锁（S 锁）的功能，它允许其他的事务也对该数据上S锁，
但是不能够允许对该数据进行修改。如果不及时的commit 或者rollback 也可能会造成大量的事务等待。
for update 和 lock in share mode 的区别：前一个上的是排他锁（X 锁），一旦一个事务获取了这个锁，
其他的事务是没法在这些数据上执行 for update ；后一个是共享锁，多个事务可以同时的对相同数据执行 lock in share mode。

InnoDB 行锁是通过给索引上的索引项加锁来实现的，没有索引InnoDB 将使用表锁

给表显示加表级锁：一般是为了在一定程度模拟事务操作，实现对某一时间点多个表的一致性读取。
Lock tables orders read local, order_detail read local; 
Select sum(total) from orders; 
Select sum(subtotal) from order_detail; 
Unlock tables;
在 LOCK TABLES 时加了“local”选项，其作用就是允许当你持有表的读锁时，
其他用户可以在满足 MyISAM 表并发插入条件的情况下，在表尾并发插入记录

InnoDB避免死锁：
为了在单个InnoDB表上执行多个并发写入操作时避免死锁，可以在事务开始时通过为预期要修改的每个行
使用SELECT ... FOR UPDATE语句来获取必要的锁，即使这些行的更改语句是在之后才执行的。
在事务中，如果要更新记录，应该直接申请足够级别的锁，即排他锁，而不应先申请共享锁、更新时再申请排他锁，
因为这时候当用户再申请排他锁时，其他事务可能又已经获得了相同记录的共享锁，从而造成锁冲突，甚至死锁。
如果事务需要修改或锁定多个表，则应在每个事务中以相同的顺序使用加锁语句。 在应用中，如果不同的程序会并发存取多个表，
应尽量约定以相同的顺序来访问表，这样可以大大降低产生死锁的机会
通过SELECT ... LOCK IN SHARE MODE获取行的读锁后，如果当前事务再需要对该记录进行更新操作，则很有可能造成死锁。

如果出现死锁，可以用 SHOW INNODB STATUS 命令来确定最后一个死锁产生的原因。返回结果中包括死锁相关事务的详细信息，
如引发死锁的 SQL 语句，事务已经获得的锁，正在等待什么锁，以及被回滚的事务等。

一些优化锁性能的建议
精心设计索引， 并尽量使用索引访问数据， 使加锁更精确， 从而减少锁冲突的机会
选择合理的事务大小，小事务发生锁冲突的几率也更小
给记录集显示加锁时，最好一次性请求足够级别的锁。比如要修改数据的话，最好直接申请排他锁，
而不是先申请共享锁，修改时再请求排他锁，这样容易产生死锁
不同的程序访问一组表时，应尽量约定以相同的顺序访问各表，对一个表而言，尽可能以固定的顺序存取表中的行。这样可以大大减少死锁的机会
尽量用相等条件访问数据，这样可以避免间隙锁对并发插入的影响
对于一些特定的事务，可以使用表锁来提高处理速度或减少死锁的可能

乐观锁,：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，
但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，适用于多读的应用类型，这样可以提高吞吐量

悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。悲观锁，顾名思义，就是很悲观，
每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会锁住直到它拿到锁。
传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。

redis                                                                   ！！！
string——适合最简单的k-v存储，类似于memcached的存储结构，短信验证码，配置信息等，就用这种类型来存储。set key "v" 
GET key   DEL key   GETRANGE key 0 3(获取val前四个字符) GETRANGE key 0 -1(获取全部)  MGET KEY1 KEY2 
(返回所有(一个或多个)给定 key 的值。 如果给定的 key 里面，有某个 key 不存在，那么这个 key 返回特殊值 nil 。)
SETEX key 60 val(为指定的 key 设置值及其过期时间。如果 key 已经存在， SETEX 命令将会替换旧的值)  STRLEN key (返回值的长度)
INCR key(储存的数字值增一)  DECR key(储存的数字值减一)  	DECRBY key int( 所储存的值减去给定的值)  	INCRBY key int

hash——一般key为ID或者唯一标示，value对应的就是详情了。如商品详情，个人信息详情，新闻详情等。
删除哈希表 key 中的一个或多个指定字段:HDEL myhash field1 field2 
查看哈希表 key 中，指定的字段是否存在:HEXISTS key field
将哈希表 key 中的字段 field 的值设为 value :HSET key field value
获取存储在哈希表中指定字段的值:HGET key field
获取在哈希表中指定 key 的所有字段和值:HGETALL key
只有在字段 field 不存在时，设置哈希表字段的值:	HSETNX key field value

list——因为list是有序的，比较适合存储一些有序且数据相对固定的数据。如省市区表、字典表等。因为list是有序的，
适合根据写入的时间来排序，如：最新的***，消息队列等。
将一个或多个值插入到列表头部:LPUSH key value1 value2
将一个或多个值插入到列表最后:RPUSH key value1 value2
移出并获取列表的第一个元素,list1 存在数据则会返回第一个元素，否则在等待100秒后会返回 nil:BLPOP list1 100
移出并获取列表的最后一个元素,list1 存在数据则会返回第一个元素，否则在等待100秒后会返回 nil:BRPOP list1 100
获取列表长度：	LLEN key
移出并获取列表的第一个元素：	LPOP key
移除列表的最后一个元素，返回值为移除的元素。：	RPOP key
将一个值插入到已存在的列表头部：LPUSHX key value
获取列表指定范围内的元素：LRANGE key 0 3
Rpoplpush 命令用于移除list1的最后一个元素，并将该元素添加到list2列表并返回： RPOPLPUSH list1 list2

set——可以简单的理解为ID-List的模式，如微博中一个人有哪些好友，set最牛的地方在于，可以对两个set提供交集、
并集、差集操作。例如：查找两个人共同的好友等。
向集合添加一个或多个成员:SADD key member1 [member2]
返回给定所有集合的交集:SINTER key1 [key2]
返回集合中的所有成员:SMEMBERS key
移除集合中一个或多个成员:SREM key member1 [member2]

Sorted Set——是set的增强版本，增加了一个score参数，自动会根据score的值进行排序。
向有序集合添加一个或多个成员，或者更新已存在成员的分数: ZADD key score1 member1 [score2 member2]
移除有序集合中的一个或多个成员: ZREM key member [member ...]
移除有序集合中给定的字典区间的所有成员: ZREMRANGEBYLEX key min max
有序集合中对指定成员的分数加上增量 increment: ZINCRBY key increment member
通过索引区间返回有序集合指定区间内的成员: ZRANGE runoobkey 0 10 WITHSCORES

数据持久化：RDB持久化配置；  AOF持久化配置
Redis的内存用完了会发生什么：这个跟 Redis 的内存回收策略有关。
Redis 的默认回收策略是 noenviction，当内存用完之后，写数据会报错。
Redis 的其他内存回收策略含义：
volatile-lru：从已设置过期时间的数据集(server.db[i].expires)中，淘汰最近最少使用的数据
volatile-ttl：从已设置过期时间的数据集(server.db[i].expires)中，淘汰最早会过期的数据
volatile-random：从已设置过期时间的数据集(server.db[i].expires)中，随机淘汰数据
allkeys-lru：从数据集(server.db[i].dict)中，淘汰最近最少使用的数据
allkeys-random：从数据集(server.db[i].dict)中，随机淘汰数据

现在说明一下，如果现在做一个秒杀，那么，Redis应该如何结合进行使用?               ！！！
提前预热数据，放入Redis
商品列表放入Redis List
商品的详情数据 Redis hash保存，设置过期时间
商品的库存数据Redis sorted set保存
用户的地址信息Redis set保存
订单产生扣库存通过Redis制造分布式锁，库存同步扣除
订单产生后发货的数据，产生Redis list，通过消息队列处理
秒杀结束后，再把Redis数据和数据库进行同步

redis队列                              ！！！
消息系统适合的场景
冗余
首先数据需要冗余的时候，比如经常做订单系统，后续需要严格的转换和记录，消息队列可以把这些数据持久化存储在队列中，
然后由订单处理程序进行获取，后续处理完成之后再把这条记录删除，保证每条记录都能处理完成。
解耦
消息队列分离了两套系统，解决了两套系统深度耦合的问题。使用消息队列后，入队的系统和出队的系统没有直接的关系，
入队系统和出队系统其中一套系统崩溃的时候，都不会影响到另一个系统的正常运转。
流量削峰
这种场景最经典的就是秒杀抢购，这种情况会出现很大的流量剧增，大量的需求集中在短短的几秒内，对服务器的瞬间压力非常大，
而我们配合缓存使用消息队列能非常有效的顶住瞬间访问量，防止服务器顶不住而崩溃。
异步通讯
消息本身可以使入队的系统直接返回，所以实现了程序的异步操作，因此只要适合于异步的场景都可以使用消息队列来实现。
扩展性
比如订单入队之后或许会有财务系统进行处理，但是后期我想加配货系统，我只需要让配货系统订阅消息队列就可以了，
这样就很容易扩展。
排序保证
这种情况指的是在有些场景下数据处理顺序是非常重要的，这种情况非常适合队列处理，因为队列本身就可以做成单线程的单进单出的系统，
从而保证数据按照顺序进行处理。

php生命周期                                             ！！！
程序开始启动->服务端处理请求->产生响应，将请求结果返回给相应的客户端->程序结束

索引类型：                                                ！！！
普通索引是最基本的索引，它没有任何限制。
唯一索引与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。
主键索引是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。
联合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。

删除数据库百万数据方法                                 ！！！
删除之前，做个完整备份。
我在删除前先保存当前索引的DDL，然后删除其索引，
然后根据使用的删除条件建立一个临时的索引（这是提高速度的另外一个重要原因！）
开始删除操作，完成之后再重建之前的索引。

依赖注入：                                                   ！！！
实质上是指：通过构造函数，或者某些情况下通过「setter」方法将类依赖「注入」到类中。
解耦，将依赖之间解耦。通过外部传入依赖，而不是自己创建依赖。
1. 控制反转是一种在软件工程中解耦合的思想，调用类只依赖接口，而不依赖具体的实现类，减少了耦合。
控制权交给了容器，在运行的时候才由容器决定将具体的实现动态的“注入”到调用类的对象中。
2. 依赖注入是一种设计模式，可以作为控制反转的一种实现方式。依赖注入就是将实例变量传入到一个对象中去。

* * * * * php /home/vagrant/Code/larabbs/artisan schedule:run >> /dev/null 2>&1                                 ！！！
一个定时任务执行输出的标准输出导向系统黑洞，/dev/null表示系统黑洞，1表示标准输出，2表示标准错误
2>&1表示 标准错误导向覆盖标准输出       因为标准输出导向系统黑洞 所以什么都不会输出

ORM                                                       ！！！
Laravel 的 Eloquent ORM 提供了一个漂亮、简洁的 ActiveRecord 实现来和数据库交互。
每个数据库表都有一个对应的「模型」用来与该表交互。你可以通过模型查询数据表中的数据，以及在数据表中插入新记录。

laravel门面                                              ！！！
简单说为了简化书写。比如缓存类，没有门面类的话。这么写
$c = new Cache(xxxx); $c->get();
或者服务容器取出来app('cache')->get();使用门面的话Cache::get();

laravel设计模式：                                               ！！！
1：工厂模式例如：Auth::user() 当我们对象对应的类名发生变化的时候，我们只需要改一下工厂类类里面的实例化方法即可。  
2：单例模式： 对象不可外部实例化并且只能实例化一次，节省资源。
3：注册树模式：config/app里的aliases数组便是一个注册树，使用数组结构来存取对象，工厂方法只需要调用一次，
以后需要调用该对象的时候直接从注册树上面取出来即可，不需要再调用工厂方法和单例模式。
4：适配器模式：将不同工具的不同函数接口封装成统一的API，方便调用。如：mysql，mysqli，PDO，实现：在接口类里面申明统一的方法体，
再让不同的类去实现这个接口，和重写其抽象方法。
5：策略模式：将一组特定的行为和算法封装成类，以适应某些特定的上下文环境，将逻辑判断和具体实现分离，实现了硬编码到解耦
6:观察者模式：触发类Event，监听类EventListener，当一个对象状态发生改变时，依赖它的对象全部会收到通知并自动更新，实现低耦合

XSS跨站脚本攻击                                       ！！！
恶意攻击者往Web页面里插入恶意html代码，当用户浏览该页之时，嵌入其中Web里面的html代码会被执行，从而达到恶意用户的特殊目的.反射型跨站。
GET或POST内容未过滤，可以提交js以及HTML等恶意代码。

token                                                      ！！！
  跨站请求伪造（CSRF）攻击。 跨站点请求伪造是一种恶意攻击，它凭借已通过身份验证的用户身份来运行未经过授权的命令。
Laravel 会自动为每个活跃的用户的会话生成一个 CSRF「令牌」。该令牌用于验证经过身份验证的用户是否是向应用程序发出请求的用户。

sql注入                                                   ！！！
比如sql语句里面加特殊符号
$query = 'SELECT * FROM `user` WHERE `username` = ' . $username . ' AND `password` = '. $password;
// 在没有过滤下 如果 $username 或者 $password 为 '1' OR 1 = 1 ,那么SQL 为
// "SELECT * FROM `user` WHERE `username` = '1' OR 1 = 1 AND `password` = '1' OR 1 = 1";
主要是过滤单引号和一些特殊符号addcslashes(),现在有的框架的内部使用的是 PDO 参数绑定，所以请求是安全的，所以在使用原生的sql语句的时候要注意过滤。
冒泡排序：                                             ！！！
function bubbleSort($arr)
{
    $len = count($arr);
    for ($i = 0; $i < $len - 1; $i++) {
        for ($j = 0; $j < $len - 1 - $i; $j++) {
            if ($arr[$j] > $arr[$j+1]) {
                $tmp = $arr[$j];
                $arr[$j] = $arr[$j+1];
                $arr[$j+1] = $tmp;
            }
        }
    }
    return $arr;
}

msql聚合函数：                                       ！！！
AVG([distinct] expr)求平均值
COUNT({*|[distinct] } expr)统计行的数量
MAX([distinct] expr)求最大值
MIN([distinct] expr)求最小值
SUM([distinct] expr)求累加和

Restful HTTP API 设计                              ！！！
1.HTTPS 为接口的安全提供了保障，可以有效防止通信被窃听和篡改。而且现在部署 HTTPS 的成本也越来越低，你可以通过 certbot 等工具，
方便快速的制作免费的安全证书，所以生产环境，请务必使用 HTTPS。
2. 域名
应当尽可能的将 API 与其主域名区分开，可以使用专用的域名，访问我们的 API，例如：https://api.larabbs.com
或者可以放在主域名下，例如：https://www.larabbs.com/api
3. 版本控制
将版本号直接加入 URL 中 ：https://api.larabbs.com/v1
使用 HTTP 请求头的 Accept 字段进行区分
4.用 URL 定位资源
在 RESTful 的架构中，所有的一切都表示资源，每一个 URL 都代表着一种资源，资源应当是一个名词，而且大部分情况下是名词的复数，
尽量不要在 URL 中出现动词
5. 用 HTTP 动词描述操作
get  post put patch delete    PUT 是根据客户端提供了完整的资源数据，客户端提交什么就替换什么，
而 PATCH 有可能是根据客户端提供的参数，动态的计算出某个值，例如每次请求后资源的某个参数减 1，所以多次调用，资源会有不同的变化。
7. 正确使用状态码
HTTP 提供了丰富的状态码供我们使用，正确的使用状态码可以让响应数据更具可读性。
200 OK - 对成功的 GET、PUT、PATCH 或 DELETE 操作进行响应。也可以被用在不创建新资源的 POST 操作上 
201 Created - 对创建新资源的 POST 操作进行响应。应该带着指向新资源地址的 Location 头 
202 Accepted - 服务器接受了请求，但是还未处理，响应中应该包含相应的指示信息，告诉客户端该去哪里查询关于本次请求的信息 
204 No Content - 对不会返回响应体的成功请求进行响应（比如 DELETE 请求）
304 Not Modified - HTTP 缓存 header 生效的时候用 
400 Bad Request - 请求异常，比如请求中的 body 无法解析 
401 Unauthorized - 没有进行认证或者认证非法 
403 Forbidden - 服务器已经理解请求，但是拒绝执行它 
404 Not Found - 请求一个不存在的资源 
405 Method Not Allowed - 所请求的 HTTP 方法不允许当前认证用户访问 
410 Gone - 表示当前请求的资源不再可用。当调用老版本 API 的时候很有用 
415 Unsupported Media Type - 如果请求中的内容类型是错误的 
422 Unprocessable Entity - 用来表示校验错误 
429 Too Many Requests - 由于请求频次达到上限而被拒绝访问
8. 数据响应格式
'message' => ':message',          // 错误的具体描述
'errors' => ':errors',            // 参数的具体错误描述，422 等状态提供
'code' => ':code',                // 自定义的异常码
'status_code' => ':status_code',  // http状态码
'debug' => ':debug',              // debug 信息，非生产环境提供
{
    "message": "422 Unprocessable Entity",
    "errors": {
        "name": [
            "姓名 必须为字符串。"
        ]
    },
    "status_code": 422
}
{
    "message": "您无权访问该订单",
    "status_code": 403
}
9. 调用频率限制
为了防止服务器被攻击，减少服务器压力，需要对接口进行合适的限流控制，需要在响应头信息中加入合适的信息，告知客户端当前的限流情况
X-RateLimit-Limit :100     最大访问次数 X-RateLimit-Remaining :93   剩余的访问次数 X-RateLimit-Reset :1513784506   到设置时间点，
剩余访问次数会重置为 最大访问次数
超过限流次数后，需要返回 429 Too Many Requests 错误。

sql优化                                                    ！！！
多表关联查询时，小表在前，大表在后：
在 MySQL 中，执行 from 后的表关联查询是从左往右执行的(Oracle 相反)，第一张表会涉及到全表扫描。
使用表的别名：
当在 SQL 语句中连接多个表时，请使用表的别名并把别名前缀于每个列名上。这样就可以减少解析的时间
大批量插入数据：
如果同时执行大量的插入，建议使用多个值的 INSERT 语句(方法二)。这比使用分开 INSERT 语句快(方法一)，一般情况下批量插入效率有几倍的差别。
方法一：insert into T values(1,2);    方法二：Insert into T values(1,2),(1,3),(1,4);  
避免不走索引的场景：
尽量避免在字段开头模糊查询，会导致数据库引擎放弃索引进行全表扫描
加索引：
在sql条件语句中经常用到where和order by的字段加上索引
在sql条件语句经常用到多个where的地方加上联合索引
数据的增删都会涉及到随索引的修改，索引越多维护成本越高，所以频繁进行数据操作的表，不要建立太多的索引；
索引越多也意味着存储空间需要越大；
                                                                                                                             ！！！
数据库主从分离：通过主库binlog单向同步，就是主库每次更新操作会有binlog产生日志，然后从库用这个binlog来同步主库数据，这个过程非常快的

面向对象的三大概念：封装，继承，多态 ； ！！！

php中抽象类和接口的区别:                        ！！！
他们的不同点： 1。抽象类中可以有非抽象的方法而接口中只能够有抽象的方法！ 2。一个类可以继承多个接口，而一个类只能继承一个抽象类！
 3。接口的使用方式通过implements关键字进行，抽象类则是通过继承extends关键字进行！
4.接口中不可以声明成员变量（包括类静态变量），但是可以声明类常量。抽象类中可以声明各种类型成员变量，实现数据的封装。
5、接口没有构造函数，抽象类可以有构造函数。
6、接口中的方法默认都是public类型的，而抽象类中的方法可以使用private,protected,public来修饰。

单点登录的三种实现方式                           ！！！
1.只需要将 Cookie 的 domain 属性设置为父域的域名（主域名），同时将 Cookie 的 path 属性设置为根路径，
这样所有的子域应用就都可以访问到这个 Cookie 了。不过这要求应用系统的域名需建立在一个共同的主域名之下，
如 tieba.baidu.com 和 map.baidu.com，它们都建立在 baidu.com 这个主域名之下，那么它们就可以通过这种方式来实现单点登录。
2.LocalStorage 跨域 (几乎有前端控制实现)
3.认证中心
可以部署一个认证中心，认证中心就是一个专门负责处理登录请求的独立的 Web 服务。
用户统一在认证中心进行登录，登录成功后，认证中心记录用户的登录状态，并将 Token 写入 Cookie。
（注意这个 Cookie 是认证中心的，应用系统是访问不到的。）
Apereo CAS 是一个企业级单点登录系统，其中 CAS 的意思是”Central Authentication Service“。它最初是耶鲁大学实验室的项目，
后来转让给了 JASIG 组织，项目更名为 JASIG CAS，后来该组织并入了 Apereo 基金会，项目也随之更名为 Apereo CAS。
4.给客户端用户发一个令牌数据，里边包含了user id，用算法加密(HMAC-SHA256)，加上一个只有我才知道的密钥， 
对数据做一个签名， 把这个签名和数据一起作为 token， 由于密钥别人不知道， 就无法伪造 token 了。
通过 Http 请求访问我的时候， 把这个 token 通过 Http header 带过来就可以了。把这个 token 给我发过来的时候，
我再用同样的算法和同样的密钥，对数据再计算一次签名， 和 token 中的签名做个比较， 如果相同， 我就知道用户已经登录过了，
并且可以直接取到用户 的 user id , 如果不相同， 数据部分肯定被人篡改过， 我就告诉发送者：对不起，没有认证。
可以使用jwt，开销很小，并且可以轻松地跨域使用。

PHP常用函数                                        ！！ ！
strip_tags() 函数剥去 HTML、XML 以及 PHP 的标签。
str_replace() 函数使用一个字符串替换字符串中的另一些字符。   implode()    explode()  sort()  ksort()  array_map()

魔术常量                                               ！！ ！
__DIR__：文件所在的目录。如果用在被包括文件中，则返回被包括的文件所在的目录。
__METHOD__ : 返回该方法被定义时的名字（区分大小写）。
__LINE__: 文件中的当前行号。
__FILE__: 文件的完整路径和文件名。如果用在被包含文件中，则返回被包含的文件名。
__NAMESPACE__: 当前命名空间的名称（区分大小写）。此常量是在编译时定义的（PHP 5.3.0 新增）。

JWT 由头部（header）、载荷（payload）与签名（signature）组成                                                 ！！！
服务器获取 Token 后，进行 base64_decode  即可获取数据进行校验，由于已经有了签名，所以不用担心数据被篡改
Laravel 为我们准备好了 auth 这个中间件
1.获取客户端提交的 token            2.检测 token 中的签名 signature 是否正确
3.判断 payload 数据中的 exp，是否已经过期   
4.根据 payload 数据中的 sub，取数据库中验证用户是否存在      
5.上述检测不正确，则抛出相应异常


